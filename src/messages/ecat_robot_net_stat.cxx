// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ecat_robot_net_stat.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "ecat_robot_net_stat.h"
#include "ecat_robot_net_statTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define NetStatMsg_max_cdr_typesize 24ULL;
#define NetStatMsg_max_key_cdr_typesize 0ULL;

NetStatMsg::NetStatMsg()
{
    // double m_delta_timestamp
    m_delta_timestamp = 0.0;
    // unsigned long m_missed_packages_tot
    m_missed_packages_tot = 0;
    // unsigned long m_missed_packages_curr
    m_missed_packages_curr = 0;
    // unsigned long m_sequence_id_curr
    m_sequence_id_curr = 0;
    // unsigned long m_sequence_id_prec
    m_sequence_id_prec = 0;

    // Just to register all known types
    registerecat_robot_net_statTypes();
}

NetStatMsg::~NetStatMsg()
{





}

NetStatMsg::NetStatMsg(
        const NetStatMsg& x)
{
    m_delta_timestamp = x.m_delta_timestamp;
    m_missed_packages_tot = x.m_missed_packages_tot;
    m_missed_packages_curr = x.m_missed_packages_curr;
    m_sequence_id_curr = x.m_sequence_id_curr;
    m_sequence_id_prec = x.m_sequence_id_prec;
}

NetStatMsg::NetStatMsg(
        NetStatMsg&& x) noexcept 
{
    m_delta_timestamp = x.m_delta_timestamp;
    m_missed_packages_tot = x.m_missed_packages_tot;
    m_missed_packages_curr = x.m_missed_packages_curr;
    m_sequence_id_curr = x.m_sequence_id_curr;
    m_sequence_id_prec = x.m_sequence_id_prec;
}

NetStatMsg& NetStatMsg::operator =(
        const NetStatMsg& x)
{

    m_delta_timestamp = x.m_delta_timestamp;
    m_missed_packages_tot = x.m_missed_packages_tot;
    m_missed_packages_curr = x.m_missed_packages_curr;
    m_sequence_id_curr = x.m_sequence_id_curr;
    m_sequence_id_prec = x.m_sequence_id_prec;

    return *this;
}

NetStatMsg& NetStatMsg::operator =(
        NetStatMsg&& x) noexcept
{

    m_delta_timestamp = x.m_delta_timestamp;
    m_missed_packages_tot = x.m_missed_packages_tot;
    m_missed_packages_curr = x.m_missed_packages_curr;
    m_sequence_id_curr = x.m_sequence_id_curr;
    m_sequence_id_prec = x.m_sequence_id_prec;

    return *this;
}

bool NetStatMsg::operator ==(
        const NetStatMsg& x) const
{

    return (m_delta_timestamp == x.m_delta_timestamp && m_missed_packages_tot == x.m_missed_packages_tot && m_missed_packages_curr == x.m_missed_packages_curr && m_sequence_id_curr == x.m_sequence_id_curr && m_sequence_id_prec == x.m_sequence_id_prec);
}

bool NetStatMsg::operator !=(
        const NetStatMsg& x) const
{
    return !(*this == x);
}

size_t NetStatMsg::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return NetStatMsg_max_cdr_typesize;
}

size_t NetStatMsg::getCdrSerializedSize(
        const NetStatMsg& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void NetStatMsg::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_delta_timestamp;
    scdr << m_missed_packages_tot;
    scdr << m_missed_packages_curr;
    scdr << m_sequence_id_curr;
    scdr << m_sequence_id_prec;

}

void NetStatMsg::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_delta_timestamp;
    dcdr >> m_missed_packages_tot;
    dcdr >> m_missed_packages_curr;
    dcdr >> m_sequence_id_curr;
    dcdr >> m_sequence_id_prec;
}

/*!
 * @brief This function sets a value in member delta_timestamp
 * @param _delta_timestamp New value for member delta_timestamp
 */
void NetStatMsg::delta_timestamp(
        double _delta_timestamp)
{
    m_delta_timestamp = _delta_timestamp;
}

/*!
 * @brief This function returns the value of member delta_timestamp
 * @return Value of member delta_timestamp
 */
double NetStatMsg::delta_timestamp() const
{
    return m_delta_timestamp;
}

/*!
 * @brief This function returns a reference to member delta_timestamp
 * @return Reference to member delta_timestamp
 */
double& NetStatMsg::delta_timestamp()
{
    return m_delta_timestamp;
}

/*!
 * @brief This function sets a value in member missed_packages_tot
 * @param _missed_packages_tot New value for member missed_packages_tot
 */
void NetStatMsg::missed_packages_tot(
        uint32_t _missed_packages_tot)
{
    m_missed_packages_tot = _missed_packages_tot;
}

/*!
 * @brief This function returns the value of member missed_packages_tot
 * @return Value of member missed_packages_tot
 */
uint32_t NetStatMsg::missed_packages_tot() const
{
    return m_missed_packages_tot;
}

/*!
 * @brief This function returns a reference to member missed_packages_tot
 * @return Reference to member missed_packages_tot
 */
uint32_t& NetStatMsg::missed_packages_tot()
{
    return m_missed_packages_tot;
}

/*!
 * @brief This function sets a value in member missed_packages_curr
 * @param _missed_packages_curr New value for member missed_packages_curr
 */
void NetStatMsg::missed_packages_curr(
        uint32_t _missed_packages_curr)
{
    m_missed_packages_curr = _missed_packages_curr;
}

/*!
 * @brief This function returns the value of member missed_packages_curr
 * @return Value of member missed_packages_curr
 */
uint32_t NetStatMsg::missed_packages_curr() const
{
    return m_missed_packages_curr;
}

/*!
 * @brief This function returns a reference to member missed_packages_curr
 * @return Reference to member missed_packages_curr
 */
uint32_t& NetStatMsg::missed_packages_curr()
{
    return m_missed_packages_curr;
}

/*!
 * @brief This function sets a value in member sequence_id_curr
 * @param _sequence_id_curr New value for member sequence_id_curr
 */
void NetStatMsg::sequence_id_curr(
        uint32_t _sequence_id_curr)
{
    m_sequence_id_curr = _sequence_id_curr;
}

/*!
 * @brief This function returns the value of member sequence_id_curr
 * @return Value of member sequence_id_curr
 */
uint32_t NetStatMsg::sequence_id_curr() const
{
    return m_sequence_id_curr;
}

/*!
 * @brief This function returns a reference to member sequence_id_curr
 * @return Reference to member sequence_id_curr
 */
uint32_t& NetStatMsg::sequence_id_curr()
{
    return m_sequence_id_curr;
}

/*!
 * @brief This function sets a value in member sequence_id_prec
 * @param _sequence_id_prec New value for member sequence_id_prec
 */
void NetStatMsg::sequence_id_prec(
        uint32_t _sequence_id_prec)
{
    m_sequence_id_prec = _sequence_id_prec;
}

/*!
 * @brief This function returns the value of member sequence_id_prec
 * @return Value of member sequence_id_prec
 */
uint32_t NetStatMsg::sequence_id_prec() const
{
    return m_sequence_id_prec;
}

/*!
 * @brief This function returns a reference to member sequence_id_prec
 * @return Reference to member sequence_id_prec
 */
uint32_t& NetStatMsg::sequence_id_prec()
{
    return m_sequence_id_prec;
}



size_t NetStatMsg::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return NetStatMsg_max_key_cdr_typesize;
}

bool NetStatMsg::isKeyDefined()
{
    return false;
}

void NetStatMsg::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

